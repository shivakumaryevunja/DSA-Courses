Linear Search:
1. Write a program to search a certain name is the given array using linear search
ans: import java.util.Scanner;
    public class LinearSearch {
    
    	public static void main(String[] args) {
    		Scanner sc = new Scanner(System.in);
    		String[] names = {"Aryan", "shiva", "Aman", "lal", "Aaron", "James"};
    		System.out.print("Enter the name to search: ");
    		String name = sc.next().toLowerCase();
    		if(linearSearch(names,name)>0) {
    			System.out.print(name+ " is present at position: "+linearSearch(names,name));
    		}else {
    			System.out.println(name+" is not present in the given array");
    		}
    		
    
    	}
    	
    	public static int linearSearch(String[] arr,String name) {
    		
    		for(int i=0;i<arr.length;i++) {
    			if(arr[i].equalsIgnoreCase(name)) {
    				return i+1;
    			}
    		}
    		return -1;
    	}
    
    }
Time complexity - O(n) in worst case scenerio and O(1) in best case scenerio

Binary Search:
2. Write a program to search a element in an array using binary search
ans: import java.util.Scanner;
    public class BinarySearch {
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int[] arr = {2,3,4,5,6,7,8,9};
            System.out.print("Enter the element to search: ");
            int key = sc.nextInt();
            binarySearch(arr,key);
        }
        public static void binarySearch(int[]arr,int key){
            int start = 0;
            int end = arr.length-1;
            while(start<=end){
                int mid = start+(end-start)/2;
    
                if(arr[mid]==key){
                    System.out.println("Element is at position: "+(mid+1));
                    return;
                }
                if(arr[mid]>key){
                    end = mid-1;
                }else{
                    start = mid+1;
                }
            }
            System.out.println("Element not fount in the given array");
        }
    }

- Time compexity for binary = O(logn) 
- Binary search can be done only on sorted arrays


3.Write a Quick sort with first element as the pivot 
ans: import java.util.Arrays;

     public class Quicksort {
    
    	public static void main(String[] args) {
    		int[]arr = {10, 7, 8, 9, 1, 5};
    		System.out.println(Arrays.toString(arr));
    		quickSort(arr,0,arr.length-1);
    		System.out.println(Arrays.toString(arr));
    
    	}
    	public static void quickSort(int[] arr,int start,int end) {
    		if(start<end) {
    			int p = sort(arr,start,end);
    			quickSort(arr,start,p-1);  
    			quickSort(arr,p+1,end);
    		}
    	}
    	
    	public static int sort(int[]arr,int start,int end) {
    		int pivot = arr[start];     //pivot value is first element
    		int p = end;      // partition index start from end of the array
    		for(int i=end;i>start;i--) {      //traverse from end and check compare with the pivot value
    			if(arr[i]>pivot) {
    				int temp = arr[i];
    				arr[i] = arr[p];
    				arr[p--] = temp;
    			}
    		}
    		int temp = arr[p];
    		arr[p] = arr[start];
    		arr[start] = temp;      // here the pivot value and pth index value is swapped
    		
    		return p;
    	}
    
    }

Time Complexity:
    Average Case: O(N * logN), where N is the length of the array.
    Best Case: O(N * logN)
    Worst Case: O(N2)
Space complexity - O(1)


